= Felt252 type

The `felt252` type represents a field element in Cairo's prime field. Field
elements use modular arithmetic and "wrap around" when their value exceeds the
field prime.

== Characteristics

- **Range**: 0 to P-1, where P = 2^251 + 17 * 2^192 + 1
- **Default type**: When no type is specified, Cairo uses `felt252`
- **Modular arithmetic**: Operations wrap around modulo P
- **Size**: 252 bits

== Syntax

[source,cairo]
----
let x: felt252 = 42;
let y = 100;  // Type inferred as felt252
----

== Modular Arithmetic

The following example demonstrates how the maximum value of `felt252` behaves
when adding `1`:

[source,cairo]
----
fn main() {
    // Maximum value of felt252 (P - 1)
    let max: felt252 =
        3618502788666131213697322783095070105623107215331596699973092056135872020480;
    let one: felt252 = 1;

    // Adding 1 wraps to 0
    assert(max + one == 0, 'P == 0 (mod P)');
}
----

== Operations

Basic arithmetic operations are supported:

[source,cairo]
----
fn main() {
    let a: felt252 = 12;
    let b: felt252 = 3;

    let sum = a + b;        // 15
    let diff = a - b;       // 9
    let prod = a * b;       // 36
}
----

NOTE: Division is not directly supported via the `/` operator. Use the
`felt252_div` function from the core library for field division.

== Negation

Arithmetic negation is performed modulo the field prime:

[source,cairo]
----
fn main() {
    let x: felt252 = 5;
    let neg_x: felt252 = -x;  // Negation modulo P
}
----

== Conversions

Converting between `felt252` and integer types:

[source,cairo]
----
use core::traits::TryInto;

fn main() {
    let f: felt252 = 42;
    let i: u32 = f.try_into().unwrap();  // felt252 -> u32

    let j: u32 = 100;
    let g: felt252 = j.into();  // u32 -> felt252
}
----

== Related

- xref:integer-types.adoc[Integer types] — Fixed-size integer types
- xref:literal-expressions.adoc[Literal expressions] — Numeric literals
- xref:arithmetic-and-logical-operators.adoc[Arithmetic operators] —
Operations on felt252
